<h1>태스크 및 백스택 이해</h1>

<u>태스크는 사용자가 특정 태스크를 수행할 때 상호 작용하는 액티비티의 모음</u>입니다. 액티비티는 각 액티비티를 여는 순서대로 스택(백 스택)으로 배열됩니다. 

Android 7.0(API 수준 24) 이상에서 지원되는 다중 창 환경에서 애플리케이션이 동시에 실행되는 경우, 시스템은 각 창에 대해 태스크를 별도로 관리합니다. 각 창에는 여러 개의 태스크가 있을 수 있습니다. 

장치 홈 화면은 대부분의 태스크의 시작 위치입니다. 사용자가 앱 런처(또는 홈 스크린의 바로 가기)의 아이콘을 터치하면 해당 앱의 태스크가 맨 앞에 나타납니다. 앱에 대한 태스크가 없는 경우(앱을 최근에 사용하지 않은 경우) 새 태스크가 생성되고 해당 앱의 "주" 태스크가 스택에서 루트 액티비티로 열립니다.

현재 액티비티가 다른 액티비티를 시작하면 새 액티비티가 스택의 맨 위에 푸시되고 포커스를 취합니다. 이전 태스크은 스택에서 유지되지만 중지됩니다. 액티비티가 중지되면 시스템은 사용자 인터페이스의 현재 상태를 유지합니다. 사용자가 뒤로 버튼을 누르면 현재 액티비티가 스택의 맨 위에서 터지고(액티비티 삭제) 이전 태스크가 다시 시작됩니다(이전 UI 상태가 복원됨). <u>스택 내의 태스크은 다시 정렬되지 않으며 스택에서 밀거나 튀어나올 때만 수행</u>되며, 현재 액티비티를 시작할 때 스택으로 푸시된 후 뒤로 버튼을 사용하여 해당 태스크를 종료하면 꺼집니다. 따라서 백 스택은 "<u>최종 in, first out" 객체 구조로 작동</u>합니다. 그림 1은 각 시점의 현재 백 스택과 함께 액티비티 간 진행 상황을 보여주는 타임라인으로 이 동작을 시각화합니다.

---

![img](https://developer.android.com/images/fundamentals/diagram_backstack.png?hl=ko)

 그림 1. 태스크의 각 새 태스크가 백 스택에 항목을 추가하는 방법을 나타냅니다. 사용자가 뒤로 버튼을 누르면 현재 액티비티가삭제되고 이전 액티비티가 재개됩니다.

---

사용자가 Back을 계속 누르고 있으면 사용자가 Home(홈) 화면으로 돌아갈 때까지(또는 태스크를 시작할 때 실행 중이던 액티비티 중) 스택의 각 태스크가 팝업됩니다. 모든 태스크가 스택에서 제거되면 태스크은 더 이상 존재하지 않습니다.  

------

![img](https://developer.android.com/images/fundamentals/diagram_multitasking.png?hl=ko)

그림 2. 두 가지 태스크: 태스크 B는 전경에서 사용자 상호 작용을 받고 태스크 A는 백그라운드에서 재개될 때까지 기다립니다.

-----------

태스크는 사용자가 홈 단추를 통해 새 태스크를 시작하거나 홈 화면으로 이동할 때 "배경"으로 이동할 수 있는 응집형 장치입니다. <u>백그라운드에서 태스크의 모든 액티비티는 중지되지만 태스크의 백 스택은 그대로 유지</u>됩니다. 그림 2와 같이 다른 태스크가 실행되는 동안 태스크에 대한 포커스가 손실되었습니다. 그러면 태스크가 "전면"으로 돌아가 사용자가 중지한 위치를 선택할 수 있습니다. ~~예를 들어~~ 현재 태스크(태스크 A)는 스택에 세 가지 액티비티(현재 태스크 아래 두 개)이 있다고 가정합니다. 사용자는 Home(홈) 버튼을 누른 다음 앱 런처에서 새 앱을 시작합니다. 홈 화면이 나타나면 태스크 A가 배경으로 이동합니다. 새 앱이 시작되면 시스템은 자체적인 태스크 스택으로 해당 앱(태스크 B)에 대한 태스크를 시작합니다. 해당 앱과 상호 작용한 후 사용자는 Home을 다시 선택하고 원래 Task A를 시작한 앱을 선택합니다. 이제 Task A는 맨 앞에 옵니다. 스택의 세 가지 태스크은 모두 그대로 유지되고 스택 맨 위의 태스크은 다시 시작됩니다. 이때 사용자는 홈으로 이동하여 태스크를 시작한 앱 아이콘을 선택하거나 Recents 화면에서 앱의 태스크를 선택하여 태스크 B로 다시 전환할 수도 있습니다. 이것은 안드로이드에서 다중태스크의 한 예이다.

`참고: 여러 태스크를 한 번에 백그라운드에서 수행할 수 있습니다. 그러나 사용자가 동시에 많은 백그라운드 태스크를 실행하는 경우 시스템은 메모리를 복구하기 위해 백그라운드 태스크를 삭제하기 시작하여 태스크 상태가 손실될 수 있습니다.`

---

![img](https://developer.android.com/images/fundamentals/diagram_multiple_instances.png?hl=ko)

그림 3. 단일 액티비티는 여러 번 인스턴스화됩니다.

---

백 스택의 액티비티는 재배치되지 않기 때문에, 앱에서 사용자가 둘 이상의 액티비티에서 특정 액티비티를 시작할 수 있는 경우 해당 태스크의 새 인스턴스가 생성되어 스택에 푸시됩니다(이전 태스크의 상위 인스턴스를 가져오는 대신). 따라서 그림 3에서와 같이 앱에서 하나의 액티비티가 여러 번 인스턴스화될 수 있습니다(다른 태스크에서도 가능). 따라서 사용자가 뒤로 버튼을 사용하여 뒤로 이동할 경우 각 액티비티 인스턴스가 열린 순서대로 표시됩니다(각각의 UI 상태). 그러나 태스크를 두 번 이상 인스턴스화하지 않으려면 이 동작을 수정할 수 있습니다. 이를 수행하는 방법은 이후 [태스크 관리에대한 섹션](https://developer.android.com/guide/components/activities/tasks-and-back-stack?hl=ko#ManagingTasks)에서 설명합니다.

액티비티 및 태스크의 기본 동작을 요약하려면

- 액티비티 A가 액티비티 B를 시작하면 액티비티 A는 중지되지만 시스템은 상태를 유지합니다(예: 양식에 입력된 텍스트 및 스크롤 위치). 액티비티 B에서 사용자가 뒤로 버튼을 누르면 액티비티 A가 재개되고 상태가 복원됩니다.
- 사용자가 홈 단추를 눌러 태스크를 종료하면 현재 태스크가 중지되고 태스크가 백그라운드로 진행됩니다. 시스템은 태스크의 모든 액티비티 상태를 유지합니다. 나중에 태스크를 시작한 시작 관리자 아이콘을 선택하여 태스크를 재개하면 태스크가 맨 위로 이동되고 스택 맨 위에 있는 태스크가 다시 시작됩니다.
- 사용자가 뒤로 버튼을 누르면 현재 액티비티가 스택에서 튀어나와 파괴됩니다. 스택의 이전 태스크가 다시 시작됩니다. 액티비티가 파괴되면 시스템은 액티비티 상태를 유지하지 않습니다.
- 액티비티는 다른 태스크에서도 여러 번 인스턴스화할 수 있습니다.  

Android에서 앱 탐색이 작동하는 방법에 대한 자세한 내용은 [Android 디자인 탐색 가이드](https://developer.android.com/design/patterns/navigation?hl=ko)를 참조하십시오.

<h2>태스크 관리</h2>

Android에서 위에서 설명한 대로 모든 액티비티를 동일한 태스크과 "최종, 첫 번째 스택" 스택에 연속해서 시작하는 방식으로 태스크 및 백 스택을 관리하는 방법은 대부분의 앱에서 잘 작동하며, 사용자는 이러한 태스크가 어떻게 관련되는지 걱정할 필요가 없습니다. 그러나 일반 동작을 중단하도록 결정할 수 있습니다. 태스크를 시작할 때(현재 태스크 내에 배치되지 않고) 새 태스크를 시작할 때 또는 태스크를 시작할 때 기존 태스크 인스턴스를 모두 스택으로 만드는 대신 해당 태스크의 인스턴스를 모두 스택으로 만들려는 경우가 있을 수 있습니다. ~~사용자가 태스크를 종료할 때 루트 액티비티.~~

[액티비티] 매니페스트 요소의 특성과 startActivity()로 전달하려는 의도로 플래그를 사용하여 이러한 태스크를 수행할 수 있습니다.

이 경우 사용할 수 있는 [액티비티] 주체의 속성은 다음과 같습니다.

- [`taskAffinity`](https://developer.android.com/guide/topics/manifest/activity-element.html?hl=ko#aff)
- [`launchMode`](https://developer.android.com/guide/topics/manifest/activity-element.html?hl=ko#lmode)
- [`allowTaskReparenting`](https://developer.android.com/guide/topics/manifest/activity-element.html?hl=ko#reparent)
- [`clearTaskOnLaunch`](https://developer.android.com/guide/topics/manifest/activity-element.html?hl=ko#clear)
- [`alwaysRetainTaskState`](https://developer.android.com/guide/topics/manifest/activity-element.html?hl=ko#always)
- [`finishOnTaskLaunch`](https://developer.android.com/guide/topics/manifest/activity-element.html?hl=ko#finish)

또한 다음과 같은 주요 의도 플래그를 사용할 수 있습니다.

- [FLAG_ACTIVITY_NEW_TASK](https://developer.android.com/reference/android/content/Intent?hl=ko#FLAG_ACTIVITY_NEW_TASK)
- [FLAG_ACTIVITY_CLEAR_TOP](https://developer.android.com/reference/android/content/Intent?hl=ko#FLAG_ACTIVITY_CLEAR_TOP)
- [FLAG_ACTIVITY_SINGLE_TOP](https://developer.android.com/reference/android/content/Intent?hl=ko#FLAG_ACTIVITY_SINGLE_TOP)

 다음 섹션에서는 이러한 매니페스트 속성 및 의도 플래그를 사용하여 태스크과 태스크가 백 스택에서 작동하는 방식을 정의하는 방법을 확인할 수 있습니다.

또한, 별도로 논의되는 것은 리셉트 화면에서 태스크과 액티비티를 나타내고 관리하는 방법에 대한 고려사항이다. 자세한 내용은 체험 화면을 참조하십시오. 일반적으로 시스템에서 액티비티들과 태스크들이 Recents 화면에 표시되는 방법을 정의할 수 있도록 해야 하며 이 동작을 수정할 필요가 없습니다.  

`주의: 대부분의 앱은 액티비티들과 태스크들의 기본 동작을 방해하지 않아야 합니다. 액티비티가 기본 동작을 수정해야 한다고 결정한 경우, Back(뒤로) 버튼을 사용하여 다른 액티비티 및 태스크에서 다시 탐색할 때 주의하고 실행 중 액티비티의 유용성을 테스트해야 합니다. 사용자의 예상 동작과 충돌할 수 있는 탐색 동작을 테스트합니다.`

<h3>시작 모드 정의</h3>

실행 모드를 사용하면 액티비티의 새 인스턴스가 현재 태스크와 연결되는 방법을 정의할 수 있습니다. 다음과 같은 두 가지 방법으로 다른 시작 모드를 정의할 수 있습니다.

- [Using the manifest file](https://developer.android.com/guide/components/activities/tasks-and-back-stack?hl=ko#ManifestForTasks)

  매니페스트 파일에서 태스크를 선언할 때 태스크를 시작할 때 태스크과 연결하는 방법을 지정할 수 있습니다.

- [Using Intent flags](https://developer.android.com/guide/components/activities/tasks-and-back-stack?hl=ko#IntentFlagsForTasks)

  startActivity()를 호출할 때 새 태스크가 현재 태스크과 어떻게(또는) 연관되어야 하는지를 알리는 플래그를 'Intent'에 포함시킬 수 있습니다.

따라서 액티비티 A가 액티비티 B를 시작하는 경우 액티비티 B는 매니페스트에서 현재 태스크과 연관되는 방법을 정의하고 액티비티 A는 액티비티 B가 현재 태스크과 연결하는 방법을 요청할 수도 있습니다. 두 액티비티에서 액티비티 B가 태스크과 연관되어야 하는 방법을 정의한 경우, 액티비티 A의 요청은 액티비티 B의 요청(의도에 정의된 대로)에 대해 존중됩니다(표시에 정의된 대로).

`참고: 매니페스트 파일에 사용할 수 있는 일부 시작 모드는 의도에 대한 플래그로 사용할 수 없으며, 마찬가지로 의도에 대한 플래그로 사용할 수 있는 일부 시작 모드를 매니페스트에 정의할 수 없습니다.`

<h4>매니페스트 파일 사용</h4>

 매니페스트 파일에 액티비티를 선언할 때 [액티비티] 요소의 lunchMode 속성을 사용하여 태스크를 태스크과 연결하는 방법을 지정할 수 있습니다.

startMode 속성은 태스크를 시작하는 방법에 대한 지침을 지정합니다. lunchMode 속성에 할당할 수 있는 4가지 실행 모드는 다음과 같습니다.  

---

`standard`(기본 모드)

체납 시스템은 시작된 태스크에 대한 액티비티 인스턴스를 새로 생성하고 해당 태스크의 의도를 라우팅합니다. 태스크는 여러 번 인스턴스화할 수 있으며 각 인스턴스는 서로 다른 태스크에 속할 수 있으며 한 태스크에는 여러 인스턴스가 포함될 수 있습니다.

(참고 :   **standard** 의 경우는 intent 를 통해 launch 될 때마다 매번 새로운 instance 를 생성합니다.)

---

`singleTop`

액티비티의 인스턴스가 현재 태스크의 맨 위에 이미 있는 경우, 시스템은 액티비티의 새 인스턴스를 생성하는 것이 아니라 해당 인스턴스에 대한 호출을 통해 해당 의도를 새 액티비티로 라우팅합니다. 액티비티는 여러 번 인스턴스(instance)될 수 있으며, 각 인스턴스는 서로 다른 태스크에 속할 수 있으며, 한 태스크에는 여러 인스턴스가 포함될 수 있습니다(백 스택의 맨 위에 있는 태스크가 기존 액티비티 인스턴스가 아닌 경우에만).
예를 들어 태스크의 백 스택이 루트 태스크 A와 액티비티 B, C 및 D로 구성된다고 가정합니다(스택은 A-B-C-D, D는 상단에 있음). D 유형의 액티비티를 위한 의도가 도착합니다. D에 기본 "표준" 시작 모드가 있는 경우 클래스의 새 인스턴스가 시작되고 스택이 A-B-C-D-D가 됩니다. 그러나 D의 시작 모드가 "singleTop"인 경우 기존 D 인스턴스는 스택의 맨 위에 있으므로 NewIntent()를 통해 의도를 수신합니다. 스택은 A-B-C-D로 유지됩니다. 그러나 B 유형의 액티비티에 대한 의도가 도착하면 B의 시작 모드가 "singleTop"인 경우에도 B의 새 인스턴스가 스택에 추가됩니다.

`참고: 액티비티의 새 인스턴스가 생성될 때 사용자는 뒤로 버튼을 눌러 이전 태스크로 돌아갈 수 있습니다. 그러나 기존 액티비티 인스턴스가 새 의도를 처리하는 경우 사용자는 새 의도가 NewIntent()에 도착하기 전에 Back 버튼을 눌러 액티비티의 상태로 돌아갈 수 없습니다.`

---

`singleTask`

시스템은 새 태스크를 생성하고 새 태스크의 루트에서 액태비티를 인스턴스화합니다. 그러나 액티비티의 인스턴스가 이미 별도의 태스크에 존재하는 경우, 시스템은 새로운 인스턴스를 생성하는 것이 아니라 새로운 인스턴스로 호출을 통해 기존 인스턴스로 의도를 라우팅한다. 한 번에 하나의 액티비티 인스턴스만 존재할 수 있습니다.
`참고: 액티비티가 새 태스크로 시작되지만 뒤로 버튼을 누르면 이전 태스크로 돌아갑니다.`

---

`singleInstance`

시스템은 새 태스크를 생성하고 새 태스크의 루트에서 액티비티를 인스턴스화합니다. 그러나 액티비티의 인스턴스가 이미 별도의 태스크에 존재하는 경우, 시스템은 새로운 인스턴스를 생성하는 것이 아니라 새로운 인스턴스로 호출을 통해 기존 인스턴스로 의도를 라우팅한다. 한 번에 하나의 액티비티 인스턴스만 존재할 수 있습니다.
참고: 액티비티가 새 태스크로 시작되지만 뒤로 버튼을 누르면 이전 태스크로 돌아갑니다.

---

 ~~또 다른 예~~로 Android 브라우저 앱은 "액티비티" 요소에 단일 태스크 시작 모드를 지정하여 웹 브라우저 태스크가 항상 자체 태스크에서 열려 있어야 함을 선언합니다. 즉, 앱에서 Android 브라우저를 열려는 의도를 가진 경우, 앱의 액티비티가 앱과 동일한 태스크에 배치되지 않습니다. 대신 브라우저에 대해 새 태스크가 시작되거나 브라우저의 백그라운드에서 이미 실행 중인 태스크가 있는 경우 해당 태스크가 앞으로 이동하여 새 의도를 처리합니다.

액티비티가 새 태스크에서 시작되었는지 또는 시작된 액티비티와 동일한 태스크에서 시작되었는지 여부에 관계없이 뒤로 버튼을 누르면 항상 이전 태스크가 수행됩니다. 그러나 단일 태스크 실행 모드를 지정하는 태스크를 시작하면 해당 태스크의 인스턴스가 백그라운드 태스크에 있는 경우 전체 태스크가 맨 앞에 표시됩니다. 이 시점에서 백 스택은 이제 스택 맨 위에 있는 이후 태스크의 모든 액티비티를 포함합니다. 그림 4는 이러한 유형의 시나리오를 보여줍니다.  

---

![img](https://developer.android.com/images/fundamentals/diagram_backstack_singletask_multiactivity.png?hl=ko)

그림 4. 시작 모드 "singleTask"가 백 스택에 추가된 방법을 나타냅니다. 액티비티가 이미 자체 백 스택이 있는 백그라운드 태스크의 일부인 경우 전체 백 스택도 현재 태스크 위에 표시됩니다.

---

`매니페스트 파일에서 시작 모드를 사용하는 방법에 대한 자세한 내용은 lunchMode속성과 허용되는 값에 대해 자세히 설명하는 [액티비티] 요소 설명서를 참조하십시오.` [lunchMode](https://developer.android.com/guide/topics/manifest/activity-element?hl=ko#lmode)

<h4>의도한 플래그 사용</h4>

액티비티를 시작할 때 startActivity()로 전달하려는 의도에 플래그를 포함하여 해당 태스크에 대한 기본 액티비티 연결을 수정할 수 있습니다. 기본 동작을 수정하는 데 사용할 수 있는 플래그는 다음과 같습니다.

[FLAG_ACTIVITY_NEW_TASK](https://developer.android.com/reference/android/content/Intent.html?hl=ko#FLAG_ACTIVITY_NEW_TASK)

새 태스크에서 태스크를 시작하십시오. 현재 시작 중인 태스크에 대해 태스크가 이미 실행 중인 경우 해당 태스크가 마지막 상태가 복원되고 태스크가 NewIntent()에 있는 새 의도를 수신합니다.

이렇게 하면 이전 섹션에서 설명한 "singleTask" startMode 값과 동일한 동작이 발생합니다.

[FLAG_ACTIVITY_SINGLE_TOP](https://developer.android.com/reference/android/content/Intent.html?hl=ko#FLAG_ACTIVITY_SINGLE_TOP)

시작 중인 태스크가 현재 태스크(백 스택 맨 위에 있음)인 경우 기존 인스턴스는 액티비티의 새 인스턴스를 생성하는 대신 NewIntent()에 대한 호출을 받습니다.
이렇게 하면 이전 섹션에서 설명한 "singleTop" unchMode 값과 동일한 동작이 발생합니다.

[FLAG_ACTIVITY_CLEAR_TOP](https://developer.android.com/reference/android/content/Intent.html?hl=ko#FLAG_ACTIVITY_CLEAR_TOP)

  현재 태스크에서 시작된 액티비티가 이미 실행 중인 경우 해당 태스크의 새 인스턴스를 시작하는 대신 해당 태스크의 다른 모든 태스크가 삭제되고(지금 위에 있음) 이 의도가 다시 시작된 액티비티의 인스턴스로 전달됩니다.
이 동작을 생성하는 startMode 속성에 대한 값이 없습니다.

FLAG_ACTIVITY_CLEAR_TOP는 FLAG_ACTIVITY_NEW_TASK와 함께 사용하는 경우가 많습니다.  

`참고: 지정된 액티비티의 시작 모드가 "standard"이면 스택에서도 제거되고 들어오는 의도를 처리하기 위해 새 인스턴스가 대신 시작됩니다. 그 이유는 시작 모드가 "표준"일 때 새로운 의도를 위해 새 인스턴스가 항상 생성되기 때문입니다.`

<h4>선호도 처리</h4>

  이 선호도는 태스크가 속한 태스크를 나타냅니다. 기본적으로 동일한 앱의 모든 태스크에는 서로에 대한 선호도가 있습니다. 따라서 기본적으로 동일한 앱의 모든 액티비티은 동일한 태스크를 수행하는 것을 선호합니다. 그러나 태스크의 기본 선호도를 수정할 수 있습니다. 다른 앱에서 정의된 액티비티은 선호도를 공유할 수 있으며, 동일한 앱에서 정의된 액티비티에는 서로 다른 태스크 선호도를 할당할 수 있습니다.

[액티비티] 요소의 taskAffinity 특성을 사용하여 지정된 태스크에 대한 선호도를 수정할 수 있습니다.

taskAffinity 속성은 문자열 값을 사용합니다. 이 값은 시스템이 해당 이름을 사용하여 앱의 기본 태스크 선호도를 식별하므로 [manifest] 요소에 선언된 기본 패키지 이름과 고유해야 합니다.  

선호도는 두 가지 상황에서 작용합니다.

-   액티비티를 시작하는 의도에는 `FLAG_ACTIVITY_NEW_TASK` 플래그가 포함됩니다.
    기본적으로 새 액티비티은 startActivity()라고 하는 태스크의 태스크로 시작됩니다. 발신자와 동일한 백 스택에 푸시됩니다. 그러나 startActivity()로 전달된 의도에 FLAG_ACTIVITITY_NEW_TASK 플래그가 포함된 경우 시스템은 새 액티비티를 저장할 다른 태스크를 찾습니다. 종종, 그것은 새로운 일이다. 하지만 그럴 필요는 없습니다. 새 액티비티과 동일한 선호도를 가진 기존 태스크가 이미 있는 경우 해당 태스크은 해당 태스크로 시작됩니다. 그렇지 않으면 새 태스크가 시작됩니다. 

  이 플래그로 인해 액티비티가 새 태스크를 시작하고 사용자가 홈 버튼을 눌러 태스크를 종료하면 사용자가 태스크로 돌아갈 수 있는 방법이 있어야 합니다. 일부 기업(예: 알림 관리자)은 항상 외부 태스크에서 액티비티를 시작하지 않기 때문에 항상 FLAG_ACTIVITY_NEW_TASK를 전달된 방식으로 배치합니다. 이 플래그를 사용할 수 있는 외부 엔티티가 호출할 수 있는 태스크가 있는 경우 시작 도구 아이콘(예: 시작 도구 태스크)을 사용하여 시작된 태스크로 돌아갈 수 있는 독립적인 방법을 사용자에게 확인합니다.  

-  태스크에 allowTaskReparenting 특성이 "true"로 설정된 경우.
    이 경우 액티비티은 시작된 태스크에서 해당 태스크가 전경으로 이동할 때 선호도가 있는 태스크로 이동할 수 있습니다.

  예를 들어, 선택된 도시의 날씨 상태를 보고하는 액티비티가 여행 앱의 일부로 정의된다고 가정하자. 동일한 앱의 다른 액티비티(기본 앱 선호도)과 동일한 선호도를 가지며 이 속성을 사용하여 다시 상위화할 수 있습니다. 액티비티 중 하나가 기상 리포터 액티비티를 시작하면, 처음에는 여러분의 액티비티과 동일한 태스크에 속합니다. 그러나 여행 앱의 태스크가 전면에 나타나면 기상 리포터 액티비티가 해당 태스크로 재할당되어 해당 태스크에 표시됩니다. 

  `팁: APK 파일에 사용자의 관점에서 두 개 이상의 "앱"이 포함되어 있는 경우 taskAffinity 특성을 사용하여 각 "앱"과 관련된 액티비티에 서로 다른 유사성을 할당해야 할 수 있습니다.`

<h4>백스택 지우기</h4>

사용자가 태스크를 오랫동안 종료하면 시스템은 루트 액티비티를 제외한 모든 태스크의 태스크를 지웁니다. 사용자가 다시 태스크로 돌아가면 루트 태스크만 복원됩니다. 이 시스템은 이렇게 동작합니다. 왜냐하면 오랜 시간 후에 사용자들은 이전에 하던 것을 포기하고 새로운 것을 시작하기 위해 다시 업무에 복귀할 가능성이 있기 때문입니다.

이 동작을 수정하는 데 사용할 수 있는 몇 가지 액티비티 특성이 있습니다.

[alwaysRetainTaskState](https://developer.android.com/guide/topics/manifest/activity-element.html?hl=ko#always)

이 특성이 태스크의 루트 태스크에서 "참"으로 설정된 경우 방금 설명한 기본 동작은 수행되지 않습니다. 이 태스크은 오랜 기간이 지난 후에도 스택 내의 모든 액티비티를 유지합니다.

[clearTaskOnLaunch](https://developer.android.com/guide/topics/manifest/activity-element.html?hl=ko#clear)

태스크의 루트 태스크에서 이 속성을 "참"으로 설정하면 사용자가 태스크를 종료하고 다시 시작할 때마다 스택이 루트 태스크로 삭제됩니다. 다시 말해, 이것은 항상 RetailTaskState와 반대되는 것입니다. 사용자는 태스크를 잠시 중지한 후에도 항상 초기 상태로 태스크로 돌아갑니다.

[finishOnTaskLaunch](https://developer.android.com/guide/topics/manifest/activity-element.html?hl=ko#finish)

이 특성은 ClearTaskOnLaunch와 비슷하지만 전체 태스크가 아닌 단일 태스크에서 작동합니다. 그것은 또한 뿌리의 액티비티를 포함한 어떤 액티비티도 사라지게 할 수 있다. 이 태스크를 "참"으로 설정하면 태스크은 현재 세션에 대해서만 태스크의 일부로 유지됩니다. 사용자가 태스크를 종료한 후 다시 태스크로 돌아가면 해당 태스크가 더 이상 없습니다.

<h4>태스크 시작</h4>

태스크를 "안드로이드"가 포함된 의도 필터를 태스크의 진입점으로 설정할 수 있습니다.의향.주(Main)는 지정된 태스크로, "Android(Andand)"로 지정됩니다.의향 범주LAUNCHER"이 지정된 카테고리로 지정됩니다. 예를 들면 다음과 같다.

```
<activity ... >
    <intent-filter ... >
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.LAUNCHER" />
    </intent-filter>
    ...
</activity>
```

이러한 종류의 의도 필터로 인해 태스크 아이콘과 라벨이 앱 런처에 표시되므로 사용자는 액티비티를 시작하고 태스크가 시작된 후 언제든지 생성한 태스크로 돌아갈 수 있습니다.

이 두 번째 기능은 중요합니다. 사용자는 태스크를 중단하고 나중에 이 태스크 실행기를 사용하여 다시 태스크를 수행할 수 있어야 합니다. 따라서 항상 태스크를 시작하는 것으로 표시하는 두 개의 시작 모드인 "singleTask"와 "singleInstance"는 액티비티가 ACT가 있는 경우에만 사용해야 합니다.ION_MAIN 및 CATEGORY_LAUNCHER 필터. 예를 들어, 필터가 누락된 경우 어떤 일이 발생할 수 있는지 상상해 보십시오. 의향은 "단일 태스크"을 시작하고, 새 태스크를 시작하고, 사용자는 해당 태스크에서 약간의 시간을 소비합니다. 그런 다음 홈 버튼을 누릅니다. 이제 태스크가 백그라운드로 전송되고 표시되지 않습니다. 이제 사용자는 태스크로 돌아갈 수 없습니다. 태스크가 앱 런처에 표시되지 않기 때문입니다.

사용자가 액티비티로 돌아갈 수 없도록 하려면 [액티비티] 요소의 피니시를 "참"으로 설정합니다(백 스택 지우기 참조).

개요 화면에서 태스크과 액티비티가 표현되고 관리되는 방법에 대한 자세한 내용은 Recents 화면에서 확인할 수 있습니다.